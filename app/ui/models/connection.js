(function() {
  var EVENT_STATE, STATE, TIME_ALL, TIME_SOME, checkEventState, checkTimer, exp, info, later, merge, ref, tryparse, wrapAction;

  ({tryparse, later} = require('../util'));

  STATE = {
    CONNECTING: 'connecting', // exactly match corresponding event name
    CONNECTED: 'connected', // exactly match corresponding event name
    CONNECT_FAILED: 'connect_failed' // exactly match corresponding event name
  };

  EVENT_STATE = {
    IN_SYNC: 'in_sync', // when we certain we have connection/events
    MISSING_SOME: 'missing_some', // when more than 40 secs without any event
    MISSING_ALL: 'missing_all' // when more than 10 minutes without any event
  };

  TIME_SOME = 40 * 1000; // 40 secs

  TIME_ALL = 10 * 60 * 1000; // 10 mins

  merge = function(t, ...os) {
    var i, k, len, o, v;
    for (i = 0, len = os.length; i < len; i++) {
      o = os[i];
      for (k in o) {
        v = o[k];
        if (v !== null && v !== (void 0)) {
          t[k] = v;
        }
      }
    }
    return t;
  };

  info = {
    connecting: 'Connectingâ€¦',
    connected: 'Connected',
    connect_failed: 'Not connected',
    unknown: 'Unknown'
  };

  module.exports = exp = {
    state: null, // current connection state
    eventState: null, // current event state
    lastActive: (ref = tryparse(localStorage.lastActive)) != null ? ref : 0, // last activity timestamp
    wasConnected: false,
    setState: function(state) {
      if (this.state === state) {
        return;
      }
      this.state = state;
      if (this.wasConnected && state === STATE.CONNECTED) {
        later(function() {
          return action('syncrecentconversations');
        });
      }
      this.wasConnected = this.wasConnected || state === STATE.CONNECTED;
      return updated('connection');
    },
    setWindowOnline: function(wonline) {
      if (this.wonline === wonline) {
        return;
      }
      this.wonline = wonline;
      if (!this.wonline) {
        return this.setState(STATE.CONNECT_FAILED);
      }
    },
    infoText: function() {
      var ref1;
      return (ref1 = info[this.state]) != null ? ref1 : info.unknown;
    },
    setLastActive: function(active) {
      if (this.lastActive === active) {
        return;
      }
      return this.lastActive = localStorage.lastActive = active;
    },
    setEventState: function(state) {
      if (this.eventState === state) {
        return;
      }
      this.eventState = state;
      if (state === EVENT_STATE.IN_SYNC) {
        if (!this.lastActive) {
          this.setLastActive(Date.now());
        }
      } else if (state === EVENT_STATE.MISSING_SOME) {
        // if we have a gap of more than 40 seconds we try getting
        // any events we may have missed during that gap. notice
        // that we get 'noop' every 20-30 seconds, so there is no
        // reason for a gap of 40 seconds.
        later(function() {
          return action('syncallnewevents', this.lastActive);
        });
      } else if (state === EVENT_STATE.MISSING_ALL) {
        // if we have a gap of more than 10 minutes, we will
        // reinitialize all convs using syncrecentconversations
        // (sort of like client startup)
        later(function() {
          return action('syncrecentconversations');
        });
      }
      later(function() {
        return checkEventState();
      });
      return updated('connection');
    }
  };

  merge(exp, STATE);

  merge(exp, EVENT_STATE);

  // averissimo: not sure when checkEventState is actually called
  //  I believe this is deprecated code, or it would be better to extend the timer
  //  to 30s or so
  checkTimer = null;

  checkEventState = function() {
    var elapsed;
    elapsed = Date.now() - exp.lastActive;
    if (checkTimer) {
      clearTimeout(checkTimer);
    }
    if (elapsed >= TIME_ALL) {
      wrapAction(function() {
        return exp.setEventState(EVENT_STATE.MISSING_ALL);
      });
    } else if (elapsed >= TIME_SOME) {
      wrapAction(function() {
        return exp.setEventState(EVENT_STATE.MISSING_SOME);
      });
    } else {
      wrapAction(function() {
        return exp.setEventState(EVENT_STATE.IN_SYNC);
      });
    }
    return checkTimer = setTimeout(checkEventState, 1000);
  };

  wrapAction = function(f) {
    handle('connwrap', function() {
      return f();
    });
    return action('connwrap');
  };

}).call(this);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidWkvbW9kZWxzL2Nvbm5lY3Rpb24uanMiLCJzb3VyY2VzIjpbInVpL21vZGVscy9jb25uZWN0aW9uLmNvZmZlZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQTtBQUFBLE1BQUEsV0FBQSxFQUFBLEtBQUEsRUFBQSxRQUFBLEVBQUEsU0FBQSxFQUFBLGVBQUEsRUFBQSxVQUFBLEVBQUEsR0FBQSxFQUFBLElBQUEsRUFBQSxLQUFBLEVBQUEsS0FBQSxFQUFBLEdBQUEsRUFBQSxRQUFBLEVBQUE7O0VBQUEsQ0FBQSxDQUFDLFFBQUQsRUFBVyxLQUFYLENBQUEsR0FBb0IsT0FBQSxDQUFRLFNBQVIsQ0FBcEI7O0VBRUEsS0FBQSxHQUNJO0lBQUEsVUFBQSxFQUFnQixZQUFoQjtJQUNBLFNBQUEsRUFBZ0IsV0FEaEI7SUFFQSxjQUFBLEVBQWdCLGdCQUZoQjtFQUFBOztFQUlKLFdBQUEsR0FDSTtJQUFBLE9BQUEsRUFBaUIsU0FBakI7SUFDQSxZQUFBLEVBQWlCLGNBRGpCO0lBRUEsV0FBQSxFQUFpQixhQUZqQjtFQUFBOztFQUlKLFNBQUEsR0FBWSxFQUFBLEdBQUssS0FaakI7O0VBYUEsUUFBQSxHQUFZLEVBQUEsR0FBSyxFQUFMLEdBQVUsS0FidEI7O0VBZUEsS0FBQSxHQUFVLFFBQUEsQ0FBQyxDQUFELEVBQUEsR0FBSSxFQUFKLENBQUE7QUFBYSxRQUFBLENBQUEsRUFBQSxDQUFBLEVBQUEsR0FBQSxFQUFBLENBQUEsRUFBQTtJQUFDLEtBQUEsb0NBQUE7O01BQUEsS0FBQSxNQUFBOztZQUEyQixNQUFVLFFBQVYsTUFBZ0I7VUFBM0MsQ0FBQyxDQUFDLENBQUQsQ0FBRCxHQUFPOztNQUFQO0lBQUE7V0FBbUU7RUFBakY7O0VBRVYsSUFBQSxHQUNJO0lBQUEsVUFBQSxFQUFnQixhQUFoQjtJQUNBLFNBQUEsRUFBZ0IsV0FEaEI7SUFFQSxjQUFBLEVBQWdCLGVBRmhCO0lBR0EsT0FBQSxFQUFnQjtFQUhoQjs7RUFLSixNQUFNLENBQUMsT0FBUCxHQUFpQixH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LENBQUMsYUFBSixDQUFrQixXQUFXLENBQUMsWUFBOUI7TUFBSCxDQUFYLEVBREM7S0FBQSxNQUFBO01BR0QsVUFBQSxDQUFXLFFBQUEsQ0FBQSxDQUFBO2VBQUcsR0FBRyxDQUFDLGFBQUosQ0FBa0IsV0FBVyxDQUFDLE9BQTlCO01BQUgsQ0FBWCxFQUhDOztXQUlMLFVBQUEsR0FBYSxVQUFBLENBQVcsZUFBWCxFQUE0QixJQUE1QjtFQVRDOztFQVdsQixVQUFBLEdBQWEsUUFBQSxDQUFDLENBQUQsQ0FBQTtJQUNULE1BQUEsQ0FBTyxVQUFQLEVBQW1CLFFBQUEsQ0FBQSxDQUFBO2FBQUcsQ0FBQSxDQUFBO0lBQUgsQ0FBbkI7V0FDQSxNQUFBLENBQU8sVUFBUDtFQUZTO0FBdEZiIiwic291cmNlc0NvbnRlbnQiOlsiXG57dHJ5cGFyc2UsIGxhdGVyfSA9IHJlcXVpcmUgJy4uL3V0aWwnXG5cblNUQVRFID1cbiAgICBDT05ORUNUSU5HOiAgICAgJ2Nvbm5lY3RpbmcnICAgICAjIGV4YWN0bHkgbWF0Y2ggY29ycmVzcG9uZGluZyBldmVudCBuYW1lXG4gICAgQ09OTkVDVEVEOiAgICAgICdjb25uZWN0ZWQnICAgICAgIyBleGFjdGx5IG1hdGNoIGNvcnJlc3BvbmRpbmcgZXZlbnQgbmFtZVxuICAgIENPTk5FQ1RfRkFJTEVEOiAnY29ubmVjdF9mYWlsZWQnICMgZXhhY3RseSBtYXRjaCBjb3JyZXNwb25kaW5nIGV2ZW50IG5hbWVcblxuRVZFTlRfU1RBVEUgPVxuICAgIElOX1NZTkM6ICAgICAgICAgJ2luX3N5bmMnICAgICAgICMgd2hlbiB3ZSBjZXJ0YWluIHdlIGhhdmUgY29ubmVjdGlvbi9ldmVudHNcbiAgICBNSVNTSU5HX1NPTUU6ICAgICdtaXNzaW5nX3NvbWUnICAjIHdoZW4gbW9yZSB0aGFuIDQwIHNlY3Mgd2l0aG91dCBhbnkgZXZlbnRcbiAgICBNSVNTSU5HX0FMTDogICAgICdtaXNzaW5nX2FsbCcgICAjIHdoZW4gbW9yZSB0aGFuIDEwIG1pbnV0ZXMgd2l0aG91dCBhbnkgZXZlbnRcblxuVElNRV9TT01FID0gNDAgKiAxMDAwICAgICAgIyA0MCBzZWNzXG5USU1FX0FMTCAgPSAxMCAqIDYwICogMTAwMCAjIDEwIG1pbnNcblxubWVyZ2UgICA9ICh0LCBvcy4uLikgLT4gdFtrXSA9IHYgZm9yIGssdiBvZiBvIHdoZW4gdiBub3QgaW4gW251bGwsIHVuZGVmaW5lZF0gZm9yIG8gaW4gb3M7IHRcblxuaW5mbyA9XG4gICAgY29ubmVjdGluZzogICAgICdDb25uZWN0aW5n4oCmJ1xuICAgIGNvbm5lY3RlZDogICAgICAnQ29ubmVjdGVkJ1xuICAgIGNvbm5lY3RfZmFpbGVkOiAnTm90IGNvbm5lY3RlZCdcbiAgICB1bmtub3duOiAgICAgICAgJ1Vua25vd24nXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwID1cbiAgICBzdGF0ZTogbnVsbCAgICAgICAjIGN1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZVxuICAgIGV2ZW50U3RhdGU6IG51bGwgICMgY3VycmVudCBldmVudCBzdGF0ZVxuICAgIGxhc3RBY3RpdmU6IHRyeXBhcnNlKGxvY2FsU3RvcmFnZS5sYXN0QWN0aXZlKSA/IDAgIyBsYXN0IGFjdGl2aXR5IHRpbWVzdGFtcFxuICAgIHdhc0Nvbm5lY3RlZDogZmFsc2VcblxuICAgIHNldFN0YXRlOiAoc3RhdGUpIC0+XG4gICAgICAgIHJldHVybiBpZiBAc3RhdGUgPT0gc3RhdGVcbiAgICAgICAgQHN0YXRlID0gc3RhdGVcbiAgICAgICAgaWYgQHdhc0Nvbm5lY3RlZCBhbmQgc3RhdGUgPT0gU1RBVEUuQ09OTkVDVEVEXG4gICAgICAgICAgICBsYXRlciAtPiBhY3Rpb24gJ3N5bmNyZWNlbnRjb252ZXJzYXRpb25zJ1xuICAgICAgICBAd2FzQ29ubmVjdGVkID0gQHdhc0Nvbm5lY3RlZCBvciBzdGF0ZSA9PSBTVEFURS5DT05ORUNURURcbiAgICAgICAgdXBkYXRlZCAnY29ubmVjdGlvbidcblxuICAgIHNldFdpbmRvd09ubGluZTogKHdvbmxpbmUpIC0+XG4gICAgICAgIHJldHVybiBpZiBAd29ubGluZSA9PSB3b25saW5lXG4gICAgICAgIEB3b25saW5lID0gd29ubGluZVxuICAgICAgICB1bmxlc3MgQHdvbmxpbmVcbiAgICAgICAgICAgIEBzZXRTdGF0ZSBTVEFURS5DT05ORUNUX0ZBSUxFRFxuXG4gICAgaW5mb1RleHQ6IC0+IGluZm9bQHN0YXRlXSA/IGluZm8udW5rbm93blxuXG4gICAgc2V0TGFzdEFjdGl2ZTogKGFjdGl2ZSkgLT5cbiAgICAgICAgcmV0dXJuIGlmIEBsYXN0QWN0aXZlID09IGFjdGl2ZVxuICAgICAgICBAbGFzdEFjdGl2ZSA9IGxvY2FsU3RvcmFnZS5sYXN0QWN0aXZlID0gYWN0aXZlXG5cbiAgICBzZXRFdmVudFN0YXRlOiAoc3RhdGUpIC0+XG4gICAgICAgIHJldHVybiBpZiBAZXZlbnRTdGF0ZSA9PSBzdGF0ZVxuICAgICAgICBAZXZlbnRTdGF0ZSA9IHN0YXRlXG4gICAgICAgIGlmIHN0YXRlID09IEVWRU5UX1NUQVRFLklOX1NZTkNcbiAgICAgICAgICAgIEBzZXRMYXN0QWN0aXZlIERhdGUubm93KCkgdW5sZXNzIEBsYXN0QWN0aXZlXG4gICAgICAgIGVsc2UgaWYgc3RhdGUgPT0gRVZFTlRfU1RBVEUuTUlTU0lOR19TT01FXG4gICAgICAgICAgICAjIGlmIHdlIGhhdmUgYSBnYXAgb2YgbW9yZSB0aGFuIDQwIHNlY29uZHMgd2UgdHJ5IGdldHRpbmdcbiAgICAgICAgICAgICMgYW55IGV2ZW50cyB3ZSBtYXkgaGF2ZSBtaXNzZWQgZHVyaW5nIHRoYXQgZ2FwLiBub3RpY2VcbiAgICAgICAgICAgICMgdGhhdCB3ZSBnZXQgJ25vb3AnIGV2ZXJ5IDIwLTMwIHNlY29uZHMsIHNvIHRoZXJlIGlzIG5vXG4gICAgICAgICAgICAjIHJlYXNvbiBmb3IgYSBnYXAgb2YgNDAgc2Vjb25kcy5cbiAgICAgICAgICAgIGxhdGVyIC0+IGFjdGlvbiAnc3luY2FsbG5ld2V2ZW50cycsIEBsYXN0QWN0aXZlXG4gICAgICAgIGVsc2UgaWYgc3RhdGUgPT0gRVZFTlRfU1RBVEUuTUlTU0lOR19BTExcbiAgICAgICAgICAgICMgaWYgd2UgaGF2ZSBhIGdhcCBvZiBtb3JlIHRoYW4gMTAgbWludXRlcywgd2Ugd2lsbFxuICAgICAgICAgICAgIyByZWluaXRpYWxpemUgYWxsIGNvbnZzIHVzaW5nIHN5bmNyZWNlbnRjb252ZXJzYXRpb25zXG4gICAgICAgICAgICAjIChzb3J0IG9mIGxpa2UgY2xpZW50IHN0YXJ0dXApXG4gICAgICAgICAgICBsYXRlciAtPiBhY3Rpb24gJ3N5bmNyZWNlbnRjb252ZXJzYXRpb25zJ1xuICAgICAgICBsYXRlciAtPiBjaGVja0V2ZW50U3RhdGUoKVxuICAgICAgICB1cGRhdGVkICdjb25uZWN0aW9uJ1xuXG5tZXJnZSBleHAsIFNUQVRFXG5tZXJnZSBleHAsIEVWRU5UX1NUQVRFXG5cbiMgYXZlcmlzc2ltbzogbm90IHN1cmUgd2hlbiBjaGVja0V2ZW50U3RhdGUgaXMgYWN0dWFsbHkgY2FsbGVkXG4jICBJIGJlbGlldmUgdGhpcyBpcyBkZXByZWNhdGVkIGNvZGUsIG9yIGl0IHdvdWxkIGJlIGJldHRlciB0byBleHRlbmQgdGhlIHRpbWVyXG4jICB0byAzMHMgb3Igc29cbmNoZWNrVGltZXIgPSBudWxsXG5jaGVja0V2ZW50U3RhdGUgPSAtPlxuICAgIGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gZXhwLmxhc3RBY3RpdmVcbiAgICBjbGVhclRpbWVvdXQgY2hlY2tUaW1lciBpZiBjaGVja1RpbWVyXG4gICAgaWYgZWxhcHNlZCA+PSBUSU1FX0FMTFxuICAgICAgICB3cmFwQWN0aW9uIC0+IGV4cC5zZXRFdmVudFN0YXRlIEVWRU5UX1NUQVRFLk1JU1NJTkdfQUxMXG4gICAgZWxzZSBpZiBlbGFwc2VkID49IFRJTUVfU09NRVxuICAgICAgICB3cmFwQWN0aW9uIC0+IGV4cC5zZXRFdmVudFN0YXRlIEVWRU5UX1NUQVRFLk1JU1NJTkdfU09NRVxuICAgIGVsc2VcbiAgICAgICAgd3JhcEFjdGlvbiAtPiBleHAuc2V0RXZlbnRTdGF0ZSBFVkVOVF9TVEFURS5JTl9TWU5DXG4gICAgY2hlY2tUaW1lciA9IHNldFRpbWVvdXQgY2hlY2tFdmVudFN0YXRlLCAxMDAwXG5cbndyYXBBY3Rpb24gPSAoZikgLT5cbiAgICBoYW5kbGUgJ2Nvbm53cmFwJywgLT4gZigpXG4gICAgYWN0aW9uICdjb25ud3JhcCdcbiJdfQ==
